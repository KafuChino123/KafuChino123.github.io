<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPT103-L1-Introduction</title>
    <url>/2024/02/27/CPT103-L1/</url>
    <content><![CDATA[<p>#CPT103 #Database<br>这节是CPT103这个学期的第一节课，主要是数据库整体的概念，应用和一些基本的术语(Terminologies)。我看了一下那些术语，好多感觉还不太好记，所以就在这里简单总结一下。<br>*中文对应名词及相关解释参考了维基百科，以及Google Gemini给出的部分解答。</p>
<h2 id="Basic-Terminologies"><a href="#Basic-Terminologies" class="headerlink" title="Basic Terminologies"></a>Basic Terminologies</h2><p><strong>relation(关系)</strong>: 简单理解就是一个有行有列的表格，更准确地说是关系数据库(relational database)中的一系列元组(tuple)的集合。</p>
<p><strong>attribute(特性)</strong>: 一个纵列。许多非关系型数据库或多值数据库系统中，列对应于特性。</p>
<p><strong>domain(域)</strong>: 一组具有相同数据类型和约束的属性值的集合。</p>
<p><img src="/pictures/CPT103-L1/attribute.jpg" alt="关系特性域" title="关系特性域" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>Tuple(元组)</strong>: 关系中的一行数据，也称为记录(record)。</p>
<p><strong>The degree of a relation(关系的度)</strong>: 指关系中特性的个数。例如，一个关系包含姓名、年龄、性别三个特性，那么该关系的度为3。</p>
<p><strong>Cardinality(基数)</strong>: 指数据库中某个表的某个列中不重复行的总个数。</p>
<p>以下名词可以互相替换：<br><img src="/pictures/CPT103-L1/alternativeTerminologies.png" alt="alternativeTerminologies" title="alternativeTerminologies" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="Relation-Keys"><a href="#Relation-Keys" class="headerlink" title="Relation Keys"></a>Relation Keys</h2><p><strong>Superkey(超键)</strong>: 关系中能唯一标识元组的属性集合。换句话说，超键是能够确定关系中每个元组的唯一性的属性集合。</p>
<p><strong>Candidate key(候选键)</strong>: 关系中能够唯一标识元组的属性集合，但是要满足：候选键中的属性(特性)不能有任何冗余。</p>
<p><strong>Primary key(主键)</strong>: 关系中用于唯一标识每个元组的属性或属性组，但是有以下特点：①主键中的值必须唯一，不能重复；②主键不能包含空值；③主键的值不能被修改；④ 一个关系中只能有一个主键。</p>
<p><strong>Alternate key(替代键)</strong>: 指除了主键之外的，能够唯一标识关系中每个元组的属性或属性组。同样要求：①替代键中值唯一；②不能包含空值。</p>
<p><strong>composite key(复合键)</strong>: 由多个列（字段）组成的键。这些列结合在一起形成一个唯一的索引，用于唯一标识数据库中的每个记录。</p>
<p>*这些键有包含关系，均属于超键，所以超键的特点其他键也都具有：<br><img src="/pictures/CPT103-L1/relationKeys.png" alt="relationKeys" title="relationKeys" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>foreign key(外键)</strong>: 引用另一个表中的主键（primary key）的列。外键用于建立表之间的关系，并确保数据的完整性和一致性。</p>
<hr>
<p>如有错误，请及时指出～评论发邮件均可，欧内盖！</p>
]]></content>
      <categories>
        <category>XJTLU</category>
      </categories>
      <tags>
        <tag>CPT103</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自学笔记-第一章</title>
    <url>/2024/03/04/ComNet-C1/</url>
    <content><![CDATA[<p>#计算机网络</p>
<p>计算机网络系列笔记根据B站课程 <a href="https://space.bilibili.com/360996402">@湖科大教书匠</a> 的课程总结而来，供自学以及分享使用。<br><a href="https://www.bilibili.com/video/BV1NT411g7n6?p=3&vd_source=bda40cfe75d1533c45205d7bec39503b">&lt;课程链接&gt;</a></p>
<h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><h3 id="网络、互联网和因特网"><a href="#网络、互联网和因特网" class="headerlink" title="网络、互联网和因特网"></a>网络、互联网和因特网</h3><p>• 网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。</p>
<p>• 多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网。<br>————因此，互联网也称为“网络的网络(Network of Networks)”。</p>
<p>• 因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。<br>————连接在因特网上的计算机称为主机（host）<br><img src="/pictures/ComNet-C1/%E7%BD%91%E7%BB%9C.png" alt="网络" title="网络" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/pictures/ComNet-C1/ivsI.png" alt="ivsI" title="ivsI" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h3><p>• 因特网发展的三个阶段：<br><img src="/pictures/ComNet-C1/%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="三个阶段" title="三个阶段" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>• 因特网服务提供者：ISP（Internet Service Provider）<br>————我国的ISP就是三大运营商：移动联通电信（广电：？<br>————给他们缴纳一定费用，他们给主机一个IP地址，从而让主机能够在因特网中通信</p>
<p>• ISP的三层结构：<br><img src="/pictures/ComNet-C1/ISP%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="ISP三层结构" title="ISP三层结构" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>————顺带一提，一旦某个用户能够接入到因特网，那么他也可以成为一个ISP。（购买调制解调器或路由器等设备，让其他用户和他相连。）</p>
<p>• 因特网的标准化工作：<br><img src="/pictures/ComNet-C1/%E6%A0%87%E5%87%86%E5%8C%96.png" alt="标准化" title="标准化" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>• 因特网的管理机构：<br><img src="/pictures/ComNet-C1/%E7%AE%A1%E7%90%86.png" alt="管理" title="管理" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>• 因特网的组成：<br><img src="/pictures/ComNet-C1/%E7%BB%84%E6%88%90.png" alt="组成" title="组成" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="电路交换、分组交换和报文交换"><a href="#电路交换、分组交换和报文交换" class="headerlink" title="电路交换、分组交换和报文交换"></a>电路交换、分组交换和报文交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换分为三个步骤：</p>
<ul>
<li><strong>建立连接</strong>：分配通信资源</li>
<li><strong>通话</strong>：一直占用通信资源</li>
<li><strong>释放连接</strong>：归还通信资源</li>
</ul>
<p>例子：旧时的电话通信：<br><img src="/pictures/ComNet-C1/%E7%94%B5%E8%AF%9D%E9%80%9A%E4%BF%A1.png" alt="电话通信" title="电话通信" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>计算机之间的数据传送是突发式</strong>的，当<strong>使用电路交换</strong>来传送计算机数据时，其<strong>线路的传输效率一般都会很低</strong>，线路上真正用来传送数据的时间往往不到10%甚至1%。因此，计算机网络通常采用<strong>分组交换</strong>。</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul>
<li><p>通常，我们把表示消息的整块数据称为一个<strong>报文</strong><br>————而较长的报文不适宜直接传输（对交换节点的缓存容量有很大的需求，在错误处理方面也会比较低效），所以会划分成若干个较小的等长数据段，同时为其添加<strong>首部</strong>：<br><img src="/pictures/ComNet-C1/%E9%A6%96%E9%83%A8.png" alt="首部" title="首部" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>首部的作用：最重要的是包含了<strong>分组的目的地址</strong>。</p>
</li>
<li><p>分组可以途径不同的路径最后到达目的地址。</p>
</li>
</ul>
<p><img src="/pictures/ComNet-C1/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.png" alt="分组交换" title="分组交换" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>分组交换的优点</strong>：</p>
<ul>
<li>没有建立连接和释放连接的过程；</li>
<li>分组传输过程中逐段占用通信链路，有较高的通信线路利用率；</li>
<li>交换节点可以为每一个分组独立选择转发路由，使得网络有很好的生存性。</li>
</ul>
<p><strong>分组交换的缺点</strong>：</p>
<ul>
<li>分组首部带来了额外的传输开销；</li>
<li>交换节点存储转发分组会造成一定的时延；</li>
<li>无法确保通信时端到端通信资源全部可用，在通信量较大时可能造成网络拥塞。</li>
</ul>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul>
<li>报文交换是分组交换的前身。</li>
<li>在报文交换中，<strong>报文被整个地发送</strong>，而不是拆开成若干个分组进行发送。</li>
<li>交换节点将报文<strong>整体接收完成后</strong>才能查找转发表，将整个报文转发到下一个节点。</li>
<li>因此，报文交换比分组交换带来的转发时延要长很多，需要交换节点具有的缓存空间也大很多。</li>
</ul>
<h3 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h3><p><img src="/pictures/ComNet-C1/%E5%AF%B9%E6%AF%94.png" alt="对比" title="对比" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>若要传送大量的数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而<strong>计算机的数据传送</strong>往往是<strong>突发式</strong>的，<strong>采用电路交换</strong>时通信<strong>线路的利用率会很低</strong>。</p>
</li>
<li><p>报文交换和分组交换都<strong>不需要建立连接</strong>（即预先分配通信资源），在<strong>传送计算机的突发数据</strong>时可以<strong>提高通信线路的利用率</strong>。</p>
</li>
<li><p>将报文构造成若干个更小的分组进行<strong>分组交换</strong>，比将整个报文进行报文交换的<strong>时延要小</strong>，并且还可以<strong>避免太长的报文长时间占用链路</strong>，<strong>有利于差错控制</strong>，同时具有更好的灵活性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>INT104-T1-Python</title>
    <url>/2024/02/29/INT104-T1/</url>
    <content><![CDATA[<p>#INT104 #Python</p>
<p>这节课，正式开始了我们本学期的Python学习之旅。Python是一种易于学习的“解释性语言”：不需要预先编译，可以快速开发和测试代码 —— 这也是为什么 Python 文件运行的速度要比 C 为代表的编译型语言快得多的主要原因。</p>
<p>本篇文章总结了 tutorial 1 主要的语法知识点。（因为在这之前相信都有上学期的Java基础，所以以Python的语法特点为重点，对关键字的定义和用途不作过多解释。）</p>
<h3 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable (变量)"></a>Variable (变量)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line">y = <span class="number">4</span></span><br><span class="line">z = x * y</span><br><span class="line">answer = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>

<h3 id="Types-类型"><a href="#Types-类型" class="headerlink" title="Types (类型)"></a>Types (类型)</h3><p><img src="/pictures/INT104-T1/types.png" alt="types" title="types" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="Casting-types-强制转换"><a href="#Casting-types-强制转换" class="headerlink" title="Casting types (强制转换)"></a>Casting types (强制转换)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>     <span class="comment"># This is an integer</span></span><br><span class="line">y = <span class="string">&quot;20&quot;</span>   <span class="comment"># This is a string</span></span><br><span class="line">z= x + <span class="built_in">int</span>(y)</span><br></pre></td></tr></table></figure>

<h3 id="Strings-字符串"><a href="#Strings-字符串" class="headerlink" title="Strings (字符串)"></a>Strings (字符串)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&quot;This can be&quot;</span></span><br><span class="line">y = <span class="string">&quot;repeated &quot;</span></span><br><span class="line">z = x + <span class="string">&quot; &quot;</span> + y * <span class="number">3</span></span><br><span class="line">x = x.upper() <span class="comment">#字符串内容大写</span></span><br><span class="line">x = x.lower() <span class="comment">#字符串内容小写</span></span><br></pre></td></tr></table></figure>

<h3 id="Multiline-strings-多行字符串"><a href="#Multiline-strings-多行字符串" class="headerlink" title="Multiline strings (多行字符串)"></a>Multiline strings (多行字符串)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&quot;&quot;&quot; To include</span></span><br><span class="line"><span class="string">multiple lines</span></span><br><span class="line"><span class="string">you have to do this&quot;&quot;&quot;</span></span><br><span class="line">y = <span class="string">&quot; or you can\ninclude the special\n character`\\n`between lines&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Lists-列表"><a href="#Lists-列表" class="headerlink" title="Lists (列表)"></a>Lists (列表)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a list of strings</span></span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;tomato&quot;</span>, <span class="string">&quot;banana&quot;</span>] </span><br><span class="line">fruits[<span class="number">2</span>]    <span class="comment"># indexing a list</span></span><br><span class="line"><span class="built_in">len</span>(fruits)  <span class="comment"># the length of a list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a list with integers</span></span><br><span class="line"><span class="comment"># Syntax : range(start point, end point, step size)</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(nums) <span class="comment"># -&gt; [0, 5, 10, 15, 20, 25] The end point is not included</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slicing lists</span></span><br><span class="line"><span class="comment"># Syntax: List[start point : end point : step size ]</span></span><br><span class="line">nums2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"><span class="built_in">print</span>(nums2[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># get from item 1(starting point) through item 5(end point, not included) with step size 2</span></span><br><span class="line"><span class="built_in">print</span>(nums2[<span class="number">0</span>:<span class="number">3</span>])    <span class="comment"># get items 0 through 3</span></span><br><span class="line"><span class="built_in">print</span>(nums2[<span class="number">4</span>:])     <span class="comment"># get items 4 onwards</span></span><br><span class="line"><span class="built_in">print</span>(nums2[-<span class="number">1</span>])     <span class="comment"># get the last item</span></span><br><span class="line"><span class="built_in">print</span>(nums2[::-<span class="number">1</span>])   <span class="comment"># get the whole list backwards</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># helpful functions</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(nums))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(nums))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(nums))</span><br><span class="line"></span><br><span class="line"><span class="comment"># lists can be of different types</span></span><br><span class="line">mixed = [<span class="number">3</span>, <span class="string">&quot;Two&quot;</span>, <span class="literal">True</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Tuples-元组"><a href="#Tuples-元组" class="headerlink" title="Tuples(元组)"></a>Tuples(元组)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;tomato&quot;</span>, <span class="string">&quot;banana&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>那么问题来了，tuples和lists的区别是什么？<br>这里有一些解答：<br><img src="/pictures/INT104-T1/tuplesvslists.png" alt="tuplesvslists" title="tuplesvslists" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="Sets-集合"><a href="#Sets-集合" class="headerlink" title="Sets (集合)"></a>Sets (集合)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;       <span class="comment"># a set created directly</span></span><br><span class="line">y = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])  <span class="comment"># a set created from a list</span></span><br><span class="line">x == y                 <span class="comment"># True, x and y are the same object</span></span><br></pre></td></tr></table></figure>

<h3 id="Dictionaries-字典"><a href="#Dictionaries-字典" class="headerlink" title="Dictionaries (字典)"></a>Dictionaries (字典)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Syntax: name = &#123;key: value&#125;</span></span><br><span class="line">days = &#123;<span class="string">&quot;Monday&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Tuesday&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">days[<span class="string">&quot;Monday&quot;</span>]  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">days.update(&#123;<span class="string">&quot;Saturday&quot;</span>: <span class="string">&quot;6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">days.pop(<span class="string">&quot;Monday&quot;</span>) <span class="comment"># remove a day</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(days.keys())    <span class="comment"># dict_keys([&#x27;Tuesday&#x27;, &#x27;Saturday&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(days.values())  <span class="comment"># dict_values([&#x27;2&#x27;, &#x27;6&#x27;])</span></span><br></pre></td></tr></table></figure>

<hr>
<p>如有错误，请及时指出～评论发邮件均可，欧内盖！</p>
]]></content>
      <categories>
        <category>XJTLU</category>
      </categories>
      <tags>
        <tag>INT104</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中 struct 和 class 的区别</title>
    <url>/2024/03/02/diffBetweenSC/</url>
    <content><![CDATA[<p>#Swift</p>
<p>Swift，作为一个面向对象语言，也是有 <code>class</code> 关键字的。<br>但是不同于Java，C# 等语言，它的 <code>class</code> 似乎并不是很常用（？<br>而在SwiftUI中，<code>class</code>的功能似乎被 <code>struct</code> 取代——行使和 <code>class</code> 相似的功能，但是我还是时常不清楚二者的区别。所以在此总结一下😋。<br>——部分解答参考了Google Gemini给出的回答，如有错误，请务必及时指出！欧内盖！</p>
<p>Swift 中的 <code>struct</code> 和 <code>class</code> 都是用来定义自定义数据类型的，它们之间有许多相似之处，但也有一些关键的区别。</p>
<p><strong>值类型与引用类型</strong></p>
<p>最大的区别在于 struct 是值类型，而 class 是引用类型。这意味着：</p>
<ul>
<li><strong>值类型</strong>：将一个值类型变量赋值给另一个变量时，会将该值的副本赋值给另一个变量。因此，对其中一个变量的更改不会影响另一个变量。</li>
<li><strong>引用类型</strong>：将一个引用类型变量赋值给另一个变量时，只会将该变量对对象的引用赋值给另一个变量。因此，对其中一个变量的更改会影响另一个变量。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> a</span><br><span class="line"></span><br><span class="line">b.x <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.x) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(b.x) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Point</code> 就是一个值类型。因此，将 <code>a</code> 赋值给 <code>b</code> 时，会将 <code>a</code> 的值复制给 <code>b</code>。在这之后，如果对 <code>b.x</code> 做更改， <code>a.x</code> 的值不会受到影响。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John&quot;</span>, age: <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> d <span class="operator">=</span> c</span><br><span class="line"></span><br><span class="line">d.age <span class="operator">=</span> <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.age) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">print</span>(d.age) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Person</code> 是一个引用类型。因此，将 <code>c</code> 赋值给 <code>d</code> 时，只会将 <code>c</code> 对对象的引用赋值给 <code>d</code>。在这之后，如果对 <code>d.age</code> 的值做出更改，<code>c.age</code> 的值也会受到影响。</p>
<p><strong>其他区别</strong></p>
<ul>
<li><strong>继承</strong>：class 可以继承自另一个 class，而 struct 不能。</li>
<li><strong>初始化</strong>：struct 有默认的成员初始化器，而 class 没有。</li>
<li><strong>可变性</strong>：struct 实例默认是不可变的，而 class 实例是可变的。</li>
<li><strong>类型转换</strong>：class 实例可以进行类型转换，而 struct 实例不能。</li>
</ul>
<p><strong>选择使用 struct 还是 class</strong></p>
<p>一般来说，如果不需要继承或类型转换，并且希望使用值语义，则应使用 struct。如果需要继承或类型转换，或者需要可变实例，则应使用 class。</p>
<p>以下是一些使用 struct 和 class 的示例：</p>
<ul>
<li><strong>使用 struct 表示简单的数据值</strong>，例如点、大小或颜色。</li>
<li><strong>使用 struct 表示不可变的数据</strong>，例如日期或时间。</li>
<li><strong>使用 class 表示复杂的数据结构</strong>，例如用户或文档。</li>
<li><strong>使用 class 表示需要继承的数据结构</strong>，例如视图控制器或网络请求。</li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World - The first post!</title>
    <url>/2024/02/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
