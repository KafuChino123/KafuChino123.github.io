<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPT103-L1-Introduction</title>
    <url>/2024/02/27/CPT103-L1/</url>
    <content><![CDATA[<p>#CPT103 #Database<br>这节是CPT103这个学期的第一节课，主要是数据库整体的概念，应用和一些基本的术语(Terminologies)。我看了一下那些术语，好多感觉还不太好记，所以就在这里简单总结一下。<br>*中文对应名词及相关解释参考了维基百科，以及Google Gemini给出的部分解答。</p>
<h2 id="Basic-Terminologies"><a href="#Basic-Terminologies" class="headerlink" title="Basic Terminologies"></a>Basic Terminologies</h2><p><strong>relation(关系)</strong>: 简单理解就是一个有行有列的表格，更准确地说是关系数据库(relational database)中的一系列元组(tuple)的集合。</p>
<p><strong>attribute(特性)</strong>: 一个纵列。许多非关系型数据库或多值数据库系统中，列对应于特性。</p>
<p><strong>domain(域)</strong>: 一组具有相同数据类型和约束的属性值的集合。</p>
<p><img src="/pictures/CPT103-L1/attribute.jpg" alt="关系特性域" title="关系特性域" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>Tuple(元组)</strong>: 关系中的一行数据，也称为记录(record)。</p>
<p><strong>The degree of a relation(关系的度)</strong>: 指关系中特性的个数。例如，一个关系包含姓名、年龄、性别三个特性，那么该关系的度为3。</p>
<p><strong>Cardinality(基数)</strong>: 指数据库中某个表的某个列中不重复行的总个数。</p>
<p>以下名词可以互相替换：<br><img src="/pictures/CPT103-L1/alternativeTerminologies.png" alt="alternativeTerminologies" title="alternativeTerminologies" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="Relation-Keys"><a href="#Relation-Keys" class="headerlink" title="Relation Keys"></a>Relation Keys</h2><p><strong>Superkey(超键)</strong>: 关系中能唯一标识元组的属性集合。换句话说，超键是能够确定关系中每个元组的唯一性的属性集合。</p>
<p><strong>Candidate key(候选键)</strong>: 关系中能够唯一标识元组的属性集合，但是要满足：候选键中的属性(特性)不能有任何冗余。</p>
<p><strong>Primary key(主键)</strong>: 关系中用于唯一标识每个元组的属性或属性组，但是有以下特点：①主键中的值必须唯一，不能重复；②主键不能包含空值；③主键的值不能被修改；④ 一个关系中只能有一个主键。</p>
<p><strong>Alternate key(替代键)</strong>: 指除了主键之外的，能够唯一标识关系中每个元组的属性或属性组。同样要求：①替代键中值唯一；②不能包含空值。</p>
<p><strong>composite key(复合键)</strong>: 由多个列（字段）组成的键。这些列结合在一起形成一个唯一的索引，用于唯一标识数据库中的每个记录。</p>
<p>*这些键有包含关系，均属于超键，所以超键的特点其他键也都具有：<br><img src="/pictures/CPT103-L1/relationKeys.png" alt="relationKeys" title="relationKeys" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>foreign key(外键)</strong>: 引用另一个表中的主键（primary key）的列。外键用于建立表之间的关系，并确保数据的完整性和一致性。</p>
<hr>
<p>如有错误，请及时指出～评论发邮件均可，欧内盖！</p>
]]></content>
      <categories>
        <category>XJTLU</category>
      </categories>
      <tags>
        <tag>CPT103</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自学笔记-第一章</title>
    <url>/2024/03/02/ComNet-C1/</url>
    <content><![CDATA[<p>#计算机网络</p>
<p>计算机网络系列笔记根据B站课程 <a href="https://space.bilibili.com/360996402">@湖科大教书匠</a> 的课程总结而来，供自学以及分享使用。<br><a href="https://www.bilibili.com/video/BV1NT411g7n6?p=3&vd_source=bda40cfe75d1533c45205d7bec39503b">&lt;课程链接&gt;</a></p>
<h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><h3 id="网络、互联网和因特网"><a href="#网络、互联网和因特网" class="headerlink" title="网络、互联网和因特网"></a>网络、互联网和因特网</h3><p>• 网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。</p>
<p>• 多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网。<br>————因此，互联网也称为“网络的网络(Network of Networks)”。</p>
<p>• 因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。<br>————连接在因特网上的计算机称为主机（host）<br><img src="/pictures/ComNet-C1/%E7%BD%91%E7%BB%9C.png" alt="网络" title="网络" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/pictures/ComNet-C1/ivsI.png" alt="ivsI" title="ivsI" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h3><p>• 因特网发展的三个阶段：<br><img src="/pictures/ComNet-C1/%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="三个阶段" title="三个阶段" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>• 因特网服务提供者：ISP（Internet Service Provider）<br>————我国的ISP就是三大运营商：移动联通电信（广电：？<br>————给他们缴纳一定费用，他们给主机一个IP地址，从而让主机能够在因特网中通信</p>
<p>• ISP的三层结构：<br><img src="/pictures/ComNet-C1/ISP%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="ISP三层结构" title="ISP三层结构" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>————顺带一提，一旦某个用户能够接入到因特网，那么他也可以成为一个ISP。（购买调制解调器或路由器等设备，让其他用户和他相连。）</p>
<p>• 因特网的标准化工作：<br><img src="/pictures/ComNet-C1/%E6%A0%87%E5%87%86%E5%8C%96.png" alt="标准化" title="标准化" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>• 因特网的管理机构：<br><img src="/pictures/ComNet-C1/%E7%AE%A1%E7%90%86.png" alt="管理" title="管理" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>• 因特网的组成：<br><img src="/pictures/ComNet-C1/%E7%BB%84%E6%88%90.png" alt="组成" title="组成" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="电路交换、分组交换和报文交换"><a href="#电路交换、分组交换和报文交换" class="headerlink" title="电路交换、分组交换和报文交换"></a>电路交换、分组交换和报文交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换分为三个步骤：</p>
<ul>
<li><strong>建立连接</strong>：分配通信资源</li>
<li><strong>通话</strong>：一直占用通信资源</li>
<li><strong>释放连接</strong>：归还通信资源</li>
</ul>
<p>例子：旧时的电话通信：<br><img src="/pictures/ComNet-C1/%E7%94%B5%E8%AF%9D%E9%80%9A%E4%BF%A1.png" alt="电话通信" title="电话通信" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>计算机之间的数据传送是突发式</strong>的，当<strong>使用电路交换</strong>来传送计算机数据时，其<strong>线路的传输效率一般都会很低</strong>，线路上真正用来传送数据的时间往往不到10%甚至1%。因此，计算机网络通常采用<strong>分组交换</strong>。</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul>
<li><p>通常，我们把表示消息的整块数据称为一个<strong>报文</strong><br>————而较长的报文不适宜直接传输（对交换节点的缓存容量有很大的需求，在错误处理方面也会比较低效），所以会划分成若干个较小的等长数据段，同时为其添加<strong>首部</strong>：<br><img src="/pictures/ComNet-C1/%E9%A6%96%E9%83%A8.png" alt="首部" title="首部" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>首部的作用：最重要的是包含了<strong>分组的目的地址</strong>。</p>
</li>
<li><p>分组可以途径不同的路径最后到达目的地址。</p>
</li>
</ul>
<p><img src="/pictures/ComNet-C1/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.png" alt="分组交换" title="分组交换" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>分组交换的优点</strong>：</p>
<ul>
<li>没有建立连接和释放连接的过程；</li>
<li>分组传输过程中逐段占用通信链路，有较高的通信线路利用率；</li>
<li>交换节点可以为每一个分组独立选择转发路由，使得网络有很好的生存性。</li>
</ul>
<p><strong>分组交换的缺点</strong>：</p>
<ul>
<li>分组首部带来了额外的传输开销；</li>
<li>交换节点存储转发分组会造成一定的时延；</li>
<li>无法确保通信时端到端通信资源全部可用，在通信量较大时可能造成网络拥塞。</li>
</ul>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul>
<li>报文交换是分组交换的前身。</li>
<li>在报文交换中，<strong>报文被整个地发送</strong>，而不是拆开成若干个分组进行发送。</li>
<li>交换节点将报文<strong>整体接收完成后</strong>才能查找转发表，将整个报文转发到下一个节点。</li>
<li>因此，报文交换比分组交换带来的转发时延要长很多，需要交换节点具有的缓存空间也大很多。</li>
</ul>
<h3 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h3><p><img src="/pictures/ComNet-C1/%E5%AF%B9%E6%AF%94.png" alt="对比" title="对比" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>若要传送大量的数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而<strong>计算机的数据传送</strong>往往是<strong>突发式</strong>的，<strong>采用电路交换</strong>时通信<strong>线路的利用率会很低</strong>。</p>
</li>
<li><p>报文交换和分组交换都<strong>不需要建立连接</strong>（即预先分配通信资源），在<strong>传送计算机的突发数据</strong>时可以<strong>提高通信线路的利用率</strong>。</p>
</li>
<li><p>将报文构造成若干个更小的分组进行<strong>分组交换</strong>，比将整个报文进行报文交换的<strong>时延要小</strong>，并且还可以<strong>避免太长的报文长时间占用链路</strong>，<strong>有利于差错控制</strong>，同时具有更好的灵活性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>INT104-T1-Python</title>
    <url>/2024/02/29/INT104-T1/</url>
    <content><![CDATA[<p>#INT104 #Python</p>
<p>这节课，正式开始了我们本学期的Python学习之旅。Python是一种易于学习的“解释性语言”：不需要预先编译，可以快速开发和测试代码 —— 这也是为什么 Python 文件运行的速度要比 C 为代表的编译型语言快得多的主要原因。</p>
<p>本篇文章总结了 tutorial 1 主要的语法知识点。（因为在这之前相信都有上学期的Java基础，所以以Python的语法特点为重点，对关键字的定义和用途不作过多解释。）</p>
<h3 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable (变量)"></a>Variable (变量)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line">y = <span class="number">4</span></span><br><span class="line">z = x * y</span><br><span class="line">answer = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>

<h3 id="Types-类型"><a href="#Types-类型" class="headerlink" title="Types (类型)"></a>Types (类型)</h3><p><img src="/pictures/INT104-T1/types.png" alt="types" title="types" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="Casting-types-强制转换"><a href="#Casting-types-强制转换" class="headerlink" title="Casting types (强制转换)"></a>Casting types (强制转换)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>     <span class="comment"># This is an integer</span></span><br><span class="line">y = <span class="string">&quot;20&quot;</span>   <span class="comment"># This is a string</span></span><br><span class="line">z= x + <span class="built_in">int</span>(y)</span><br></pre></td></tr></table></figure>

<h3 id="Strings-字符串"><a href="#Strings-字符串" class="headerlink" title="Strings (字符串)"></a>Strings (字符串)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&quot;This can be&quot;</span></span><br><span class="line">y = <span class="string">&quot;repeated &quot;</span></span><br><span class="line">z = x + <span class="string">&quot; &quot;</span> + y * <span class="number">3</span></span><br><span class="line">x = x.upper() <span class="comment">#字符串内容大写</span></span><br><span class="line">x = x.lower() <span class="comment">#字符串内容小写</span></span><br></pre></td></tr></table></figure>

<h3 id="Multiline-strings-多行字符串"><a href="#Multiline-strings-多行字符串" class="headerlink" title="Multiline strings (多行字符串)"></a>Multiline strings (多行字符串)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&quot;&quot;&quot; To include</span></span><br><span class="line"><span class="string">multiple lines</span></span><br><span class="line"><span class="string">you have to do this&quot;&quot;&quot;</span></span><br><span class="line">y = <span class="string">&quot; or you can\ninclude the special\n character`\\n`between lines&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Lists-列表"><a href="#Lists-列表" class="headerlink" title="Lists (列表)"></a>Lists (列表)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a list of strings</span></span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;tomato&quot;</span>, <span class="string">&quot;banana&quot;</span>] </span><br><span class="line">fruits[<span class="number">2</span>]    <span class="comment"># indexing a list</span></span><br><span class="line"><span class="built_in">len</span>(fruits)  <span class="comment"># the length of a list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a list with integers</span></span><br><span class="line"><span class="comment"># Syntax : range(start point, end point, step size)</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(nums) <span class="comment"># -&gt; [0, 5, 10, 15, 20, 25] The end point is not included</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slicing lists</span></span><br><span class="line"><span class="comment"># Syntax: List[start point : end point : step size ]</span></span><br><span class="line">nums2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"><span class="built_in">print</span>(nums2[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># get from item 1(starting point) through item 5(end point, not included) with step size 2</span></span><br><span class="line"><span class="built_in">print</span>(nums2[<span class="number">0</span>:<span class="number">3</span>])    <span class="comment"># get items 0 through 3</span></span><br><span class="line"><span class="built_in">print</span>(nums2[<span class="number">4</span>:])     <span class="comment"># get items 4 onwards</span></span><br><span class="line"><span class="built_in">print</span>(nums2[-<span class="number">1</span>])     <span class="comment"># get the last item</span></span><br><span class="line"><span class="built_in">print</span>(nums2[::-<span class="number">1</span>])   <span class="comment"># get the whole list backwards</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># helpful functions</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(nums))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(nums))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(nums))</span><br><span class="line"></span><br><span class="line"><span class="comment"># lists can be of different types</span></span><br><span class="line">mixed = [<span class="number">3</span>, <span class="string">&quot;Two&quot;</span>, <span class="literal">True</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Tuples-元组"><a href="#Tuples-元组" class="headerlink" title="Tuples(元组)"></a>Tuples(元组)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;tomato&quot;</span>, <span class="string">&quot;banana&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>那么问题来了，tuples和lists的区别是什么？<br>这里有一些解答：<br><img src="/pictures/INT104-T1/tuplesvslists.png" alt="tuplesvslists" title="tuplesvslists" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="Sets-集合"><a href="#Sets-集合" class="headerlink" title="Sets (集合)"></a>Sets (集合)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;       <span class="comment"># a set created directly</span></span><br><span class="line">y = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])  <span class="comment"># a set created from a list</span></span><br><span class="line">x == y                 <span class="comment"># True, x and y are the same object</span></span><br></pre></td></tr></table></figure>

<h3 id="Dictionaries-字典"><a href="#Dictionaries-字典" class="headerlink" title="Dictionaries (字典)"></a>Dictionaries (字典)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Syntax: name = &#123;key: value&#125;</span></span><br><span class="line">days = &#123;<span class="string">&quot;Monday&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Tuesday&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">days[<span class="string">&quot;Monday&quot;</span>]  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">days.update(&#123;<span class="string">&quot;Saturday&quot;</span>: <span class="string">&quot;6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">days.pop(<span class="string">&quot;Monday&quot;</span>) <span class="comment"># remove a day</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(days.keys())    <span class="comment"># dict_keys([&#x27;Tuesday&#x27;, &#x27;Saturday&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(days.values())  <span class="comment"># dict_values([&#x27;2&#x27;, &#x27;6&#x27;])</span></span><br></pre></td></tr></table></figure>

<hr>
<p>如有错误，请及时指出～评论发邮件均可，欧内盖！</p>
]]></content>
      <categories>
        <category>XJTLU</category>
      </categories>
      <tags>
        <tag>INT104</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 中 struct 和 class 的区别</title>
    <url>/2024/03/02/diffBetweenSC/</url>
    <content><![CDATA[<p>#Swift</p>
<p>Swift，作为一个面向对象语言，也是有 <code>class</code> 关键字的。<br>但是不同于Java，C# 等语言，它的 <code>class</code> 似乎并不是很常用（？<br>而在SwiftUI中，<code>class</code>的功能似乎被 <code>struct</code> 取代——行使和 <code>class</code> 相似的功能，但是我还是时常不清楚二者的区别。所以在此总结一下😋。<br>——部分解答参考了Google Gemini给出的回答，如有错误，请务必及时指出！欧内盖！</p>
<p>Swift 中的 <code>struct</code> 和 <code>class</code> 都是用来定义自定义数据类型的，它们之间有许多相似之处，但也有一些关键的区别。</p>
<p><strong>值类型与引用类型</strong></p>
<p>最大的区别在于 struct 是值类型，而 class 是引用类型。这意味着：</p>
<ul>
<li><strong>值类型</strong>：将一个值类型变量赋值给另一个变量时，会将该值的副本赋值给另一个变量。因此，对其中一个变量的更改不会影响另一个变量。</li>
<li><strong>引用类型</strong>：将一个引用类型变量赋值给另一个变量时，只会将该变量对对象的引用赋值给另一个变量。因此，对其中一个变量的更改会影响另一个变量。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> a</span><br><span class="line"></span><br><span class="line">b.x <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.x) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(b.x) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Point</code> 就是一个值类型。因此，将 <code>a</code> 赋值给 <code>b</code> 时，会将 <code>a</code> 的值复制给 <code>b</code>。在这之后，如果对 <code>b.x</code> 做更改， <code>a.x</code> 的值不会受到影响。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John&quot;</span>, age: <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> d <span class="operator">=</span> c</span><br><span class="line"></span><br><span class="line">d.age <span class="operator">=</span> <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.age) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">print</span>(d.age) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Person</code> 是一个引用类型。因此，将 <code>c</code> 赋值给 <code>d</code> 时，只会将 <code>c</code> 对对象的引用赋值给 <code>d</code>。在这之后，如果对 <code>d.age</code> 的值做出更改，<code>c.age</code> 的值也会受到影响。</p>
<p><strong>其他区别</strong></p>
<ul>
<li><strong>继承</strong>：class 可以继承自另一个 class，而 struct 不能。</li>
<li><strong>初始化</strong>：struct 有默认的成员初始化器，而 class 没有。</li>
<li><strong>可变性</strong>：struct 实例默认是不可变的，而 class 实例是可变的。</li>
<li><strong>类型转换</strong>：class 实例可以进行类型转换，而 struct 实例不能。</li>
</ul>
<p><strong>选择使用 struct 还是 class</strong></p>
<p>一般来说，如果不需要继承或类型转换，并且希望使用值语义，则应使用 struct。如果需要继承或类型转换，或者需要可变实例，则应使用 class。</p>
<p>以下是一些使用 struct 和 class 的示例：</p>
<ul>
<li><strong>使用 struct 表示简单的数据值</strong>，例如点、大小或颜色。</li>
<li><strong>使用 struct 表示不可变的数据</strong>，例如日期或时间。</li>
<li><strong>使用 class 表示复杂的数据结构</strong>，例如用户或文档。</li>
<li><strong>使用 class 表示需要继承的数据结构</strong>，例如视图控制器或网络请求。</li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World - The first post!</title>
    <url>/2024/02/20/hello-world/</url>
    <content><![CDATA[<p>#Hexo<br>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>CPT103-L2-SQL</title>
    <url>/2024/03/05/CPT103-L2/</url>
    <content><![CDATA[<p>#CPT103 #Database</p>
<p>CPT103 Lecture的第二节课，主要讲了<strong>SQL(Structured Query Language)<strong>、</strong>一些基本的创建表格的语法</strong>和<strong>一些元组(Tuple)的操作</strong>。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>SQL(Structured Query Language, 结构化查询语言)，是一种特定目的编程语言，用于管理关系数据库管理系统(RDBMS)，或在关系流数据管理系统(RDSMS)中进行流处理。</p>
<p><strong>SQL有三个重要的部分</strong>：</p>
<ul>
<li>数据定义语言(Data Definition Language, DDL):<br>用于定义和管理数据库对象，包括数据库、表、索引、视图、存储过程、触发器等。DDL语句用于定义和修改数据库对象的结构，不会直接对数据库中的数据进行操作。<br>DDL语句常用的关键字包括：</li>
</ul>
<p><code>CREATE</code>：用于创建数据库对象，例如表、索引、视图等。<br><code>ALTER</code>：用于修改数据库对象的结构，例如添加或删除列、修改列的数据类型等。<br><code>DROP</code>：用于删除数据库对象。</p>
<ul>
<li>数据操纵语言(Data Manipulation Language, DML):<br>是SQL语言的一个子集，用于对数据库中的数据进行操作，包括插入、更新、删除和检索数据。DML语句用于对数据库中的数据进行增删改查，不会直接对数据库对象的结构进行操作。<br>DML语句常用的关键字包括：</li>
</ul>
<p><code>INSERT</code>：用于插入一条或多条数据到数据库中。<br><code>UPDATE</code>：用于更新数据库中的数据。<br><code>DELETE</code>：用于删除数据库中的数据。<br><code>SELECT</code>：用于从数据库中检索数据。</p>
<ul>
<li>数据控制语言(Data Control Language, DCL):<br>是 SQL 语言的一个子集，用于控制数据库用户对数据库对象的访问权限。DCL 语句不会直接对数据库中的数据或结构进行操作，而是用于授予或收回用户对数据库对象的权限。<br>DCL 语句常用的关键字包括：</li>
</ul>
<p><code>GRANT</code>：用于授予用户对数据库对象的权限。<br><code>REVOKE</code>：用于收回用户对数据库对象的权限。</p>
<h2 id="SQL的格式"><a href="#SQL的格式" class="headerlink" title="SQL的格式"></a>SQL的格式</h2><ul>
<li>需要注意的是，SQL语言对关键字的大小写并不敏感，原则上大写小写都没问题，但一般为了更好的可读性和代码的整洁规范，我们选择<strong>关键字全部大写</strong>；</li>
<li>而表格的名字、列的名字往往是大小写敏感的，所以我们选择这么写：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (sName) <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个逻辑结构-Schema"><a href="#创建一个逻辑结构-Schema" class="headerlink" title="创建一个逻辑结构(Schema)"></a>创建一个逻辑结构(Schema)</h2><p>可以：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA name;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE name;</span><br></pre></td></tr></table></figure>

<p>Schema 指的是数据库对象的逻辑结构，包括表、视图、索引、存储过程、触发器等。它定义了数据库中数据的组织方式，以及数据库对象之间的关系。</p>
<h2 id="创建我们的第一个表格"><a href="#创建我们的第一个表格" class="headerlink" title="创建我们的第一个表格"></a>创建我们的第一个表格</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_table ( </span><br><span class="line">    column1 <span class="type">int</span>, </span><br><span class="line">    column2 <span class="type">varchar</span>(<span class="number">40</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h3 id="‘USE’关键字"><a href="#‘USE’关键字" class="headerlink" title="‘USE’关键字:"></a>‘USE’关键字:</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE schema_name;</span><br></pre></td></tr></table></figure>
<p>USE关键字用于选择要使用的数据库，通常在连接到数据库服务器后立即使用，以便后续的查询和操作都针对该数据库进行。如果不使用USE关键字，则默认情况下使用当前连接的数据库。</p>
<h3 id="Inserting-Values-插入值"><a href="#Inserting-Values-插入值" class="headerlink" title="Inserting Values(插入值):"></a>Inserting Values(插入值):</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table <span class="keyword">VALUES</span>  (<span class="number">1</span>, <span class="string">&#x27;ABC&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;DEF&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>INSERT关键字用于向表中插入新记录。它是一种非常常用的SQL语句，可以用于将数据导入数据库中。<br>tips: <code>(1, &#39;ABC&#39;)</code>, <code>(2, &#39;DEF&#39;)</code>就是该table的两个元组(Tuple)。</p>
<p>此外，还可以使用**反引号(&#96;)**，这样表格或列名字命名时如果有空格，就不需要使用’_’，直接空格即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `my <span class="keyword">table</span>` (</span><br><span class="line">    `<span class="keyword">column</span> A` <span class="type">INT</span>,</span><br><span class="line">    `<span class="keyword">column</span> B` <span class="type">VARCHAR</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>但是非常不建议这么做！正常我们就用上面的普通的命名方式<code>my_table</code>就好。</p>
<h2 id="Numercial-Data-Types-数字的数据类型"><a href="#Numercial-Data-Types-数字的数据类型" class="headerlink" title="Numercial Data Types(数字的数据类型)"></a>Numercial Data Types(数字的数据类型)</h2><h3 id="Integers-整数"><a href="#Integers-整数" class="headerlink" title="Integers(整数)"></a>Integers(整数)</h3><ul>
<li><p>example: <code>INT</code> or <code>INT(5)</code><br> - 括号内表示 integer 的总位数。</p>
</li>
<li><p>SMALLINT<br> - 占用：2字节(byte)<br> - 范围：-32,768 到 32,767，是左闭右开区间，即包括-32,768但不包括32,767。</p>
</li>
<li><p>INT or INTEGER<br> - 占用：4字节<br> - 范围：-2,147,483,648 到 2,147,483,647（无符号：0 到 4,294,967,295，也是左闭右开区间。<br> - 是最经典和常用的选择。（废话</p>
</li>
<li><p>BIGINT<br> - 占用：8字节<br> - 范围：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</p>
</li>
</ul>
<h3 id="Fixed-Point-定点数"><a href="#Fixed-Point-定点数" class="headerlink" title="Fixed Point(定点数)"></a>Fixed Point(定点数)</h3><p>这是个全新的东西，细细说一下这个定点数是什么：</p>
<ul>
<li><p>example: <code>DECIMAL[(M[, D])]</code> or <code>NUMERIC[(M[, D])]</code><br>(tips: 中括号[]之间的是optional的，可有可无)<br>M -&gt; 总位数，D -&gt; 小数点后的位数<br>example：<code>price DECIMAL(10,2)</code></p>
</li>
<li><p>定点数是什么？<br> - <strong>定点数（Fixed-point number）</strong>是一种表示实数的格式，其特点是小数点的位置是固定的。</p>
</li>
<li><p>相比于浮点数，定点数的优点：<br> - 精度更高：浮点数的精度会受到指数的影响，而定点数的精度是固定的。<br> - 速度更快：定点数的运算速度比浮点数更快，因为不需要进行指数运算。<br> - 存储空间更小：定点数占用更少的存储空间，因为不需要存储指数。</p>
</li>
<li><p>定点数的缺点：<br> - 表示范围有限：定点数的表示范围由小数点的位置决定，无法表示超出范围的数字。<br> - 不适用于科学计算：定点数不适用于需要很高精度的科学计算。</p>
</li>
<li><p>定点数的表示方法：<br> - 定点数通常使用二进制表示，小数点的位置由整数部分和小数部分的位数决定。例如，一个8位定点数，其中4位整数部分，4位小数部分，可以表示的范围为-2^4到2^4-2^(-4)，精度为1&#x2F;2^(-4)。</p>
</li>
<li><p>常见的应用场景：<br> - 金融计算：定点数用于计算利率、汇率等金融数据。<br> - 嵌入式系统：定点数用于控制电机、温度等设备。<br> - 数字信号处理：定点数用于滤波、傅里叶变换等信号处理操作。</p>
</li>
</ul>
<h3 id="Float-浮点数"><a href="#Float-浮点数" class="headerlink" title="Float(浮点数)"></a>Float(浮点数)</h3><ul>
<li>example: <code>FLOAT</code> or <code>FLOAT(5)</code> or <code>FLOAT(3, 2)</code><br> - 括号内如果只有一个参数，则表示总位数；<br> - 如果有两个参数，则第一个表示总位数，第二个表示小数点后的位数。</li>
</ul>
<h3 id="String-Types-字符串类型"><a href="#String-Types-字符串类型" class="headerlink" title="String Types(字符串类型)"></a>String Types(字符串类型)</h3><ul>
<li><code>CHAR[(M)]</code> or <code>VARCHAR(M)</code><br>M -&gt; 总位数<br>(tips: 中括号[]之间的是optional的，可有可无)</li>
</ul>
<p>二者之间的区别：<br> - <strong>存储方式</strong>:<br><strong>CHAR：</strong>固定长度，以空格填充不足部分。例如，CHAR(10)类型的列，如果存储的字符串长度不足10，则会用空格补足到10个字符。<br><strong>VARCHAR：</strong>可变长度，只存储字符串实际占用的空间。例如，VARCHAR(10)类型的列，如果存储的字符串长度为5，则只占用5个字节的存储空间。</p>
<p> - <strong>性能</strong>:<br><strong>CHAR：</strong>查询效率较高，因为长度固定，可以直接进行比较。<br><strong>VARCHAR：</strong>查询效率略低，因为需要先获取字符串的实际长度，然后进行比较。</p>
<p> - <strong>使用场景</strong>:<br><strong>CHAR：</strong>适用于存储长度固定且需要精确比较的字符串，例如身份证号码、密码等。<br><strong>VARCHAR：</strong>适用于存储长度可变且不需要精确比较的字符串，例如姓名、地址等。</p>
<h3 id="String-Values-字符串值"><a href="#String-Values-字符串值" class="headerlink" title="String Values(字符串值)"></a>String Values(字符串值)</h3><ul>
<li>SQL中，字符串值使用单引号：<code>&#39;I AM A STRING&#39;</code><br>(tips: 用双引号其实也可以，这方面也不严格)</li>
<li>在字符串内部使用单引号时，前面加上反斜杠：<code>&#39;I\&#39;M A STRING&#39;</code><br>或使用双引号：<code>&#39;I&quot;M A STRING&#39;</code></li>
</ul>
<h3 id="Date-and-Time-日期与时间"><a href="#Date-and-Time-日期与时间" class="headerlink" title="Date and Time(日期与时间)"></a>Date and Time(日期与时间)</h3><ul>
<li><p><code>DATE</code>:<br> - 支持的范围：’1000-01-01’ to ‘9999-12-31’.<br> - MySQL展示日期的格式：’YYYY-MM-DD’.</p>
</li>
<li><p><code>DATETIME[(fsp)]</code><br> - 支持的范围：’1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999’.<br> - MySQL展示日期的格式：’YYYY-MM-DD hh:mm:ss[.fraction]’.</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `staff` ( </span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">60</span>), </span><br><span class="line">    `id_card` <span class="type">CHAR</span>(<span class="number">6</span>), </span><br><span class="line">    `recruit_date` <span class="type">DATE</span>, </span><br><span class="line">    `last_login` DATETIME </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>TIMESTAMP</code><br> - 和DATETIME相似，但是保存UTC时间。</li>
</ul>
<h3 id="NULL-and-Special-Values-特殊值"><a href="#NULL-and-Special-Values-特殊值" class="headerlink" title="NULL and Special Values(特殊值)"></a>NULL and Special Values(特殊值)</h3><ul>
<li><p>NULL：<br><code>NULL</code>表示未知或缺失，它不是0、””或任何其他值。NULL可以出现在任何数据类型中，包括数字、字符串、日期等。<br> - 常用于：数据尚未收集；数据无法获得；数据被删除。</p>
</li>
<li><p>Special Values：<br>指具有特殊含义的值。<br>example：<br><code>NaN</code>: 表示非数字<br><code>Infinity</code>: 表示正无穷<br><code>-Infinity</code>: 表示负无穷</p>
</li>
</ul>
<p> - 常用于：表示数据溢出或数据无效等情况。</p>
<h3 id="Column-Options-列选项"><a href="#Column-Options-列选项" class="headerlink" title="Column Options(列选项)"></a>Column Options(列选项)</h3><p><code>col-name datatype [col-options]</code></p>
<ul>
<li><code>NOT NULL</code>: 这个列的值不能为NULL；</li>
<li><code>UNIQUE</code>: 每个值都必须独一无二，不能重复；</li>
<li><code>DEFAULT value</code>: 默认值。（在MS access中不工作）</li>
<li><code>AUTO_INCREMENT</code>: 自动生成唯一数字，通常用于主键——每次向表中插入新记录时，MySQL会自动将AUTO_INCREMENT设置的列的值加1；也可以指定自增起始值，默认值为1。</li>
</ul>
<p>example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons ( </span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">    lastname <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    firstname <span class="type">VARCHAR</span>(<span class="number">255</span>), </span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">12</span>, </span><br><span class="line">    city <span class="type">VARCHAR</span>(<span class="number">255</span>) </span><br><span class="line">) AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Tuple-Manipulation-元组操作"><a href="#Tuple-Manipulation-元组操作" class="headerlink" title="Tuple Manipulation(元组操作)"></a>Tuple Manipulation(元组操作)</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><ul>
<li><p>添加一横排数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename (col1, col2, …)</span><br><span class="line"><span class="keyword">VALUES</span> (val1, val2, …), </span><br><span class="line">    ...</span><br><span class="line">    (val1,val2,val3);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果每一列都要添加值，就不用一一列出来了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename <span class="keyword">VALUES</span> (val1, val2, …);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><ul>
<li>更新一横排数据：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> col1 <span class="operator">=</span> val1 [,col2 <span class="operator">=</span> val2…]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>关于condition：<br> - condition为true的横排，对应列的值都会改变；<br> - <strong>如果不给condition，所有横排都会被改变</strong>。</li>
</ul>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><ul>
<li>删除一横排数据：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span></span><br><span class="line">    table_name </span><br><span class="line">    [<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>condition同上。</li>
</ul>
<hr>
<p>如有错误，请及时指出～评论发邮件均可，欧内盖！</p>
]]></content>
      <categories>
        <category>XJTLU</category>
      </categories>
      <tags>
        <tag>CPT103</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CPT102-L2-Huffman</title>
    <url>/2024/03/06/CPT102-L2-Huffman/</url>
    <content><![CDATA[<p>#数据结构 #CPT102</p>
]]></content>
      <categories>
        <category>XJTLU</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>CPT102</tag>
      </tags>
  </entry>
</search>
